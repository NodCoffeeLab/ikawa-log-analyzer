import streamlit as st
import pandas as pd
import numpy as np
import io
import plotly.graph_objects as go
from plotly.subplots import make_subplots
import plotly.express as px

# --- Î∞±ÏóîÎìú Ìï®Ïàò (Î≥ÄÍ≤Ω ÏóÜÏùå) ---
def calculate_ror(df):
    if df['Ïò®ÎèÑ'].isnull().all(): return df # Assuming 'Ïò®ÎèÑ' is the relevant column, adjust if needed
    last_valid_index = df['Ïò®ÎèÑ'].last_valid_index()
    if last_valid_index is None: return df
    calc_df = df.loc[0:last_valid_index].copy()
    delta_temp = calc_df['Ïò®ÎèÑ'].diff(); delta_time = calc_df['ÎàÑÏ†Å ÏãúÍ∞Ñ (Ï¥à)'].diff()
    ror = (delta_temp / delta_time).replace([np.inf, -np.inf], 0).fillna(0)
    calc_df['ROR (‚ÑÉ/sec)'] = ror; df.update(calc_df)
    return df


# --- UI Î∞è Ïï± Ïã§Ìñâ Î°úÏßÅ ---
st.set_page_config(layout="wide")
st.title("üî• Ikawa Roast Log Analyzer")
st.markdown("**(v.0.3 - Adjustments)**") # Î≤ÑÏ†Ñ ÏóÖÎç∞Ïù¥Ìä∏

# --- Session State Ï¥àÍ∏∞Ìôî (Í∏∞Î≥∏ Ï∂ï Î≤îÏúÑ ÏàòÏ†ï) ---
if 'processed_logs' not in st.session_state: st.session_state.processed_logs = {}
if 'selected_time' not in st.session_state: st.session_state.selected_time = 0
if 'axis_ranges' not in st.session_state:
    st.session_state.axis_ranges = {'x': [0, 600], 'y': [60, 300], 'y2': [0, 50]} # Í∏∞Î≥∏ Î≤îÏúÑ ÏàòÏ†ï

# --- ÏòàÏÉÅÎêòÎäî Ï†ÑÏ≤¥ Ìó§Îçî Î™©Î°ù ---
expected_headers = [
    'time', 'fan set', 'setpoint', 'fan speed', 'temp above', 'state',
    'heater', 'p', 'i', 'd', 'temp below', 'temp board', 'j', 'ror_above',
    'abs_humidity', 'abs_humidity_roc', 'abs_humidity_roc_direction',
    'adfc_timestamp', 'end_timestamp', 'tdf_error', 'pressure',
    'total_moisture_loss', 'moisture_loss_rate'
]
# --- ÌïµÏã¨ Îç∞Ïù¥ÌÑ∞ Ïó¥ Ïù¥Î¶Ñ ---
TIME_COL = 'time'
EXHAUST_TEMP_COL = 'temp above'
INLET_TEMP_COL = 'temp below'
EXHAUST_ROR_COL = 'ror_above'
STATE_COL = 'state'

# --- ÏÇ¨Ïù¥ÎìúÎ∞î UI (Í∏∞Î≥∏Í∞í ÏàòÏ†ï) ---
with st.sidebar:
    st.header("‚öôÔ∏è Î≥¥Í∏∞ ÏòµÏÖò")
    profile_names_sidebar = list(st.session_state.processed_logs.keys())
    default_selected = st.session_state.get('selected_profiles', profile_names_sidebar)
    default_selected = [p for p in default_selected if p in profile_names_sidebar]
    if not default_selected and profile_names_sidebar:
        default_selected = profile_names_sidebar
    st.session_state.selected_profiles = st.multiselect("Í∑∏ÎûòÌîÑÏóê ÌëúÏãúÌï† Î°úÍ∑∏ ÏÑ†ÌÉù", options=profile_names_sidebar, default=default_selected)

    st.subheader("Ï∂ï Î≤îÏúÑ Ï°∞Ï†à")
    axis_ranges = st.session_state.axis_ranges
    col1, col2 = st.columns(2)
    with col1:
        # value ÏàòÏ†ï
        x_min = st.number_input("XÏ∂ï ÏµúÏÜåÍ∞í(ÏãúÍ∞Ñ)", value=axis_ranges['x'][0])
        y_min = st.number_input("YÏ∂ï(Ïò®ÎèÑ) ÏµúÏÜåÍ∞í", value=axis_ranges['y'][0])
        y2_min = st.number_input("Î≥¥Ï°∞YÏ∂ï(ROR) ÏµúÏÜåÍ∞í", value=axis_ranges['y2'][0], format="%.1f") # ROR Ìè¨Îß∑ Î≥ÄÍ≤Ω Í≥†Î†§
    with col2:
        # value ÏàòÏ†ï
        x_max = st.number_input("XÏ∂ï ÏµúÎåÄÍ∞í(ÏãúÍ∞Ñ)", value=axis_ranges['x'][1])
        y_max = st.number_input("YÏ∂ï(Ïò®ÎèÑ) ÏµúÎåÄÍ∞í", value=axis_ranges['y'][1])
        y2_max = st.number_input("Î≥¥Ï°∞YÏ∂ï(ROR) ÏµúÎåÄÍ∞í", value=axis_ranges['y2'][1], format="%.1f") # ROR Ìè¨Îß∑ Î≥ÄÍ≤Ω Í≥†Î†§
    st.session_state.axis_ranges = {'x': [x_min, x_max], 'y': [y_min, y_max], 'y2': [y2_min, y2_max]}

# --- ÌååÏùº ÏóÖÎ°úÎìú UI ---
uploaded_files = st.file_uploader("CSV Î°úÍ∑∏ ÌååÏùºÏùÑ Ïó¨Í∏∞Ïóê ÏóÖÎ°úÎìúÌïòÏÑ∏Ïöî.", type="csv", accept_multiple_files=True)

# --- Îç∞Ïù¥ÌÑ∞ Î°úÎî© Î∞è Ï†ïÏ†ú ---
if uploaded_files:
    if 'files_processed' not in st.session_state or st.session_state.uploaded_file_names != [f.name for f in uploaded_files]:
        st.session_state.processed_logs.clear()
        st.session_state.selected_profiles = []
        st.write("---")
        st.subheader("‚è≥ ÌååÏùº Ï≤òÎ¶¨ Ï§ë...")

        all_files_valid = True
        log_dfs_for_processing = {}

        for uploaded_file in uploaded_files:
            profile_name = uploaded_file.name.replace('.csv', '')
            try:
                bytes_data = uploaded_file.getvalue()
                try: decoded_data = bytes_data.decode('utf-8-sig')
                except UnicodeDecodeError: decoded_data = bytes_data.decode('utf-8')
                stringio = io.StringIO(decoded_data)
                stringio.seek(0); header_line = stringio.readline().strip()
                headers = [h.strip() for h in header_line.split(',')]
                stringio.seek(0)
                # Îç∞Ïù¥ÌÑ∞ ÏùΩÏùÑ Îïå ÏóêÎü¨ ÎùºÏù∏ Î¨¥ÏãúÌïòÎèÑÎ°ù ÏàòÏ†ï
                df = pd.read_csv(stringio, header=None, skiprows=1, skipinitialspace=True, on_bad_lines='warn') # 'skip' ÎåÄÏã† 'warn' ÏÇ¨Ïö© Í≥†Î†§
                if len(headers) >= len(df.columns): df.columns = headers[:len(df.columns)]
                else: df.columns = headers + [f'unknown_{i}' for i in range(len(df.columns) - len(headers))]
                if df.columns[0] != 'time': raise ValueError("Ï≤´ Ïó¥Ïù¥ 'time'Ïù¥ ÏïÑÎãôÎãàÎã§.")

                # --- Ïó¨Í∏∞Í∞Ä ÏàòÏ†ïÎêú Î∂ÄÎ∂Ñ: ÏÉÅÌÉú ÌïÑÌÑ∞ÎßÅ Í∞ïÌôî + Ïø®ÎßÅ Ï†úÏô∏ ---
                roasting_df = pd.DataFrame()
                if STATE_COL in df.columns:
                    df[STATE_COL] = df[STATE_COL].astype(str).str.strip().str.lower()
                    # Î°úÏä§ÌåÖ ÏãúÏûë ÏßÄÏ†ê Ï∞æÍ∏∞
                    start_mask = df[STATE_COL].str.contains('roasting|ready_for_roast', case=False, na=False)
                    # Î°úÏä§ÌåÖ Ï¢ÖÎ£å ÏßÄÏ†ê Ï∞æÍ∏∞ (cooling, cooldown ÏãúÏûë Ï†ÑÍπåÏßÄ)
                    end_mask = df[STATE_COL].str.contains('cooling|cooldown', case=False, na=False)

                    start_index = -1
                    if start_mask.any():
                        start_index = df[start_mask].index[0]

                    end_index = len(df) # Í∏∞Î≥∏Í∞íÏùÄ ÎÅùÍπåÏßÄ
                    if end_mask.any():
                        end_index = df[end_mask].index[0]

                    if start_index != -1:
                        roasting_df = df.iloc[start_index:end_index].copy()
                    else:
                        st.warning(f"'{uploaded_file.name}': Î°úÏä§ÌåÖ ÏãúÏûë ÏÉÅÌÉúÎ•º Ï∞æÏùÑ Ïàò ÏóÜÏñ¥ Ï†ÑÏ≤¥ Îç∞Ïù¥ÌÑ∞Î•º ÏÇ¨Ïö©Ìï©ÎãàÎã§ (Ïø®ÎßÅ Ï†úÏô∏ ÏãúÎèÑ).")
                        # Ïø®ÎßÅ ÏÉÅÌÉúÎßå Ï†úÏô∏ÌïòÍ≥† ÏÇ¨Ïö©
                        cooling_mask = df[STATE_COL].str.contains('cooling|cooldown', case=False, na=False)
                        roasting_df = df[~cooling_mask].copy() # Ïø®ÎßÅ ÏïÑÎãå Í≤ÉÎßå ÏÑ†ÌÉù
                else:
                     st.warning(f"'{uploaded_file.name}': 'state' Ïó¥Ïù¥ ÏóÜÏñ¥ Ï†ÑÏ≤¥ Îç∞Ïù¥ÌÑ∞Î•º ÏÇ¨Ïö©Ìï©ÎãàÎã§.")
                     roasting_df = df.copy()
                # --- ÏàòÏ†ï ÎÅù ---


                if TIME_COL in roasting_df.columns and not roasting_df.empty:
                    start_time = roasting_df[TIME_COL].iloc[0]
                    roasting_df[TIME_COL] = roasting_df[TIME_COL] - start_time

                cols_to_convert = [EXHAUST_TEMP_COL, INLET_TEMP_COL, EXHAUST_ROR_COL]
                for col in cols_to_convert:
                    if col in roasting_df.columns:
                        roasting_df[col] = pd.to_numeric(roasting_df[col], errors='coerce')
                    else:
                        st.warning(f"'{uploaded_file.name}': ÌïÑÏàò Ïó¥ '{col}'Ïù¥ ÏóÜÏäµÎãàÎã§.")
                        roasting_df[col] = np.nan

                log_dfs_for_processing[profile_name] = roasting_df

            except Exception as e:
                st.error(f"'{uploaded_file.name}' ÌååÏùºÏùÑ Ï≤òÎ¶¨ÌïòÎäî Ï§ë Ïò§Î•ò Î∞úÏÉù: {e}")
                all_files_valid = False

        if all_files_valid and log_dfs_for_processing:
            st.session_state.processed_logs = log_dfs_for_processing
            st.session_state.selected_profiles = list(log_dfs_for_processing.keys())
            st.session_state.uploaded_file_names = [f.name for f in uploaded_files]
            st.session_state.files_processed = True
            st.success("‚úÖ ÌååÏùº Ï≤òÎ¶¨ ÏôÑÎ£å!")
            # st.rerun() # Ï†úÍ±∞Îê®

# --- Í∑∏ÎûòÌîÑ Î∞è Î∂ÑÏÑù Ìå®ÎÑê UI ---
if st.session_state.processed_logs:
    st.header("üìà Í∑∏ÎûòÌîÑ Î∞è Î∂ÑÏÑù")
    graph_col, analysis_col = st.columns([0.7, 0.3])
    max_time = 0
    for df in st.session_state.processed_logs.values():
        if TIME_COL in df.columns and not df[TIME_COL].dropna().empty:
            max_time = max(max_time, df[TIME_COL].max())
    max_time = max(max_time, 1)

    with graph_col:
        fig = make_subplots(specs=[[{"secondary_y": True}]])
        selected_profiles_data = st.session_state.get('selected_profiles', [])
        colors = px.colors.qualitative.Plotly
        color_map = {name: colors[i % len(colors)] for i, name in enumerate(st.session_state.processed_logs.keys())}

        for name in selected_profiles_data:
            df = st.session_state.processed_logs.get(name); color = color_map.get(name)
            if df is not None and color is not None:
                if TIME_COL in df.columns and EXHAUST_TEMP_COL in df.columns:
                    valid_df_exhaust = df.dropna(subset=[TIME_COL, EXHAUST_TEMP_COL])
                    if len(valid_df_exhaust) > 1:
                        # Ïù¥Î¶Ñ Î≥ÄÍ≤Ω
                        fig.add_trace(go.Scatter(x=valid_df_exhaust[TIME_COL], y=valid_df_exhaust[EXHAUST_TEMP_COL], mode='lines', name=f'{name} Exhaust Temp', line=dict(color=color, dash='solid'), legendgroup=name), secondary_y=False)
                if TIME_COL in df.columns and INLET_TEMP_COL in df.columns:
                     valid_df_inlet = df.dropna(subset=[TIME_COL, INLET_TEMP_COL])
                     if len(valid_df_inlet) > 1:
                         # Ïù¥Î¶Ñ Î≥ÄÍ≤Ω
                         fig.add_trace(go.Scatter(x=valid_df_inlet[TIME_COL], y=valid_df_inlet[INLET_TEMP_COL], mode='lines', name=f'{name} Inlet Temp', line=dict(color=color, dash='dash'), legendgroup=name), secondary_y=False)
                if TIME_COL in df.columns and EXHAUST_ROR_COL in df.columns:
                    valid_df_ror = df.dropna(subset=[TIME_COL, EXHAUST_ROR_COL])
                    # Ensure at least 2 points for ROR plotting after removing the first one
                    if len(valid_df_ror) > 1:
                        ror_df = valid_df_ror.iloc[1:]
                        # Check again if ror_df is not empty after slicing
                        if not ror_df.empty:
                            fig.add_trace(go.Scatter(x=ror_df[TIME_COL], y=ror_df[EXHAUST_ROR_COL], mode='lines', name=f'{name} ROR', line=dict(color=color, dash='dot'), legendgroup=name, showlegend=False), secondary_y=True)


        selected_time_int = int(st.session_state.get('selected_time', 0)); fig.add_vline(x=selected_time_int, line_width=1, line_dash="dash", line_color="grey")
        axis_ranges = st.session_state.axis_ranges
        fig.update_layout(height=700, legend=dict(orientation="h", yanchor="bottom", y=1.02, xanchor="right", x=1))
        fig.update_xaxes(range=axis_ranges['x'], title_text='ÏãúÍ∞Ñ (Ï¥à)', dtick=60)
        # Ï∂ï Î≤îÏúÑ ÏàòÏ†ï Î∞òÏòÅ
        fig.update_yaxes(title_text="Ïò®ÎèÑ (¬∞C)", range=axis_ranges['y'], dtick=10, secondary_y=False)
        fig.update_yaxes(title_text="ROR (‚ÑÉ/sec)", range=axis_ranges['y2'], showgrid=False, secondary_y=True)
        st.plotly_chart(fig, use_container_width=True)

    with analysis_col:
        st.subheader("üîç Î∂ÑÏÑù Ï†ïÎ≥¥"); st.markdown("---")
        st.write("**Ï¥ù Î°úÏä§ÌåÖ ÏãúÍ∞Ñ**")
        for name in selected_profiles_data:
            df = st.session_state.processed_logs.get(name)
            if df is not None and TIME_COL in df.columns:
                valid_df = df.dropna(subset=[TIME_COL])
                if not valid_df.empty:
                    total_time = valid_df[TIME_COL].max(); time_str = f"{int(total_time // 60)}Î∂Ñ {int(total_time % 60)}Ï¥à"
                    st.markdown(f"**{name}**: <span style='font-size: 1.1em;'>{time_str}</span>", unsafe_allow_html=True)
        st.markdown("---")
        def update_slider_time():
            st.session_state.selected_time = st.session_state.time_slider
        selected_time_val = st.session_state.get('selected_time', 0)
        slider_max_time = max(1, int(max_time))
        if selected_time_val > slider_max_time:
            selected_time_val = slider_max_time
            st.session_state.selected_time = selected_time_val
        st.slider("ÏãúÍ∞Ñ ÏÑ†ÌÉù (Ï¥à)", 0, slider_max_time, selected_time_val, 1, key="time_slider", on_change=update_slider_time)

        st.write(""); st.write("**ÏÑ†ÌÉùÎêú ÏãúÍ∞Ñ ÏÉÅÏÑ∏ Ï†ïÎ≥¥**")
        selected_time = st.session_state.selected_time; st.markdown(f"#### {int(selected_time // 60)}Î∂Ñ {int(selected_time % 60):02d}Ï¥à ({selected_time}Ï¥à)")
        for name in selected_profiles_data:
            st.markdown(f"<p style='margin-bottom: 0.2em;'><strong>{name}</strong></p>", unsafe_allow_html=True)
            exhaust_temp_str, inlet_temp_str, ror_str = "--", "--", "--"
            df = st.session_state.processed_logs.get(name)
            if df is not None:
                if TIME_COL not in df.columns: continue
                # Ïù¥Î¶Ñ Î≥ÄÍ≤Ω Î∞òÏòÅ
                if EXHAUST_TEMP_COL in df.columns:
                    valid_exhaust = df.dropna(subset=[TIME_COL, EXHAUST_TEMP_COL])
                    if len(valid_exhaust) > 1 and selected_time <= valid_exhaust[TIME_COL].max():
                        hover_exhaust = np.interp(selected_time, valid_exhaust[TIME_COL], valid_exhaust[EXHAUST_TEMP_COL]); exhaust_temp_str = f"{hover_exhaust:.1f}‚ÑÉ"
                if INLET_TEMP_COL in df.columns:
                    valid_inlet = df.dropna(subset=[TIME_COL, INLET_TEMP_COL])
                    if len(valid_inlet) > 1 and selected_time <= valid_inlet[TIME_COL].max():
                        hover_inlet = np.interp(selected_time, valid_inlet[TIME_COL], valid_inlet[INLET_TEMP_COL]); inlet_temp_str = f"{hover_inlet:.1f}‚ÑÉ"
                if EXHAUST_ROR_COL in df.columns:
                    valid_ror = df.dropna(subset=[TIME_COL, EXHAUST_ROR_COL])
                    if len(valid_ror) > 1 and selected_time <= valid_ror[TIME_COL].max():
                        hover_ror = np.interp(selected_time, valid_ror[TIME_COL], valid_ror[EXHAUST_ROR_COL]); ror_str = f"{hover_ror:.3f}‚ÑÉ/sec"
            # Ïù¥Î¶Ñ Î≥ÄÍ≤Ω Î∞òÏòÅ
            st.markdown(f"<p style='margin:0; font-size: 0.95em;'>&nbsp;&nbsp;‚Ä¢ Exhaust Temp: {exhaust_temp_str}</p>", unsafe_allow_html=True)
            st.markdown(f"<p style='margin:0; font-size: 0.95em;'>&nbsp;&nbsp;‚Ä¢ Inlet Temp: {inlet_temp_str}</p>", unsafe_allow_html=True)
            st.markdown(f"<p style='margin-bottom:0.8em; font-size: 0.95em;'>&nbsp;&nbsp;‚Ä¢ Exhaust ROR: {ror_str}</p>", unsafe_allow_html=True)

elif not uploaded_files:
    st.info("Î∂ÑÏÑùÌï† CSV ÌååÏùºÏùÑ ÏóÖÎ°úÎìúÌï¥Ï£ºÏÑ∏Ïöî.")
